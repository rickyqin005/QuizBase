package utility;

/**
 * A helper class that builds SQL Statements. Currently, only {@code CREATE TABLE},
 * {@code DROP TABLE}, {@code INSERT INTO}, {@code SELECT}, {@code UPDATE} and
 * {@code DELETE} starting clauses are supported.
 *
 * SQL Statements can be generated by calling the object's {@code .toString()} method.
 *
 * @author Ricky Qin
 */
public class SQLStatement {

    public static String ASCENDING = "ASC";
    public static String DESCENDING = "DESC";

    // private static int CREATE_TABLE = 1;
    // private static int DROP_TABLE = 2;
    private static int INSERT_INTO = 3;
    private static int SELECT = 4;
    private static int UPDATE = 5;
    private static int DELETE = 6;

    private int type = -1;

    private Pair<String, String[]> insertInto;
    private String[] values;
    private String[] select;
    private String from;
    private String where;
    private Integer limit;
    private Pair<String, String>[] orderBy;
    private String update;
    private Pair<String, String>[] set;

    public SQLStatement() {}

    /**
     * Appends the {@code INSERT TO} clause to this statement
     *
     * @param table The table to insert the new row
     * @param cols Some number of Strings, indicating the columns to populate. If no columns are specified,
     * the entire row is populated.
     * @return This SQL statement
     */
    public SQLStatement insertInto(String table, String... cols) {
        type = INSERT_INTO;
        insertInto = new Pair<>(table, cols);
        return this;
    }

    /**
     * Appends the {@code VALUES} clause to this statement
     *
     * @param cols Some number of Strings, indicating the values to populate into the columns as specified
     * in the {@code INSERT INTO} clause. Should be called immediately after {@code .insertInto()}.
     * @return This SQL statement
     */
    public SQLStatement values(String... cols) {
        values = cols;
        return this;
    }

    /**
     * Appends the {@code SELECT} clause to this statement
     *
     * @param cols Some number of Strings, indicating the columns to retrieve. If no columns are specified,
     * all of them will be retrieved.
     * @return This SQL statement
     */
    public SQLStatement select(String... cols) {
        type = SELECT;
        select = cols;
        return this;
    }

    /**
     * Appends the {@code FROM} clause to this statement
     *
     * @param table The name of the table to retrieve data from. Should be called immediately after
     * {@code .select()}.
     * @return This SQL statement
     */
    public SQLStatement from(String table) {
        from = table;
        return this;
    }

    /**
     * Appends the {@code WHERE} clause to this statement
     *
     * @param condition A string representing the condition used to filter results. Can be used for
     * {@code SELECT}, {@code UPDATE} and {@code DELETE} statements.
     * @return This SQL statement
     */
    public SQLStatement where(String condition) {
        where = condition;
        return this;
    }

    /**
     * Appends the {@code LIMIT} clause to this statement
     *
     * @param amt The maximum number of rows that can be returned by a query.
     * @return This SQL statement
     */
    public SQLStatement limit(int amt) {
        limit = amt;
        return this;
    }

    /**
     * Appends the {@code ORDER BY} clause to this statement
     *
     * @param fields Some number of Pair objects. The first value is the column to sort by and the
     * second value is one of {@code SQLStatement.ASC} or {@code SQLStatement.DESC}.
     * @return This SQL statement
     */
    public SQLStatement orderBy(Pair<String, String>... cols) {
        orderBy = cols;
        return this;
    }

    /**
     * Appends the {@code UPDATE} clause to this statement
     *
     * @param table The name of the table in which to perform the update.
     * @return This SQL statement
     */
    public SQLStatement update(String table) {
        type = UPDATE;
        update = table;
        return this;
    }

    /**
     * Appends the {@code SET} clause to this statement
     *
     * @param cols Some number of Pair objects, with the first value indicating the column to modify
     * and the second value indicating the new value.
     * @return This SQL statement
     */
    public SQLStatement set(Pair<String, String>... cols) {
        set = cols;
        return this;
    }

    /**
     * Appends the {@code DELETE} clause to this statement
     *
     * @return This SQL statement
     */
    public SQLStatement delete() {
        type = DELETE;
        return this;
    }

    /**
     * Returns the String array as a list
     *
     * @param arr The string array
     * @param brackets The surrounding brackets, where the first and last characters are the
     * opening and closing brackets respectively. If {@code null}, no brackets are used.
     * @param delimiter The delimiter
     * @return A string
     */
    public static String arrayToString(String[] arr, String brackets, String delimiter) {
        StringBuilder str = new StringBuilder();
        if(brackets != null) {
            str.append(brackets.charAt(0));
        }
        for(int i = 0; i < arr.length; i++) {
            str.append(arr[i]);
            if(i != arr.length-1) {
                str.append(delimiter);
            }
        }
        if(brackets != null) {
            str.append(brackets.charAt(1));
        }
        return str.toString();
    }

    /**
     * Outputs this object as an SQL Statement
     *
     * @return The string
     */
    @Override
    public String toString() {
        if(type == -1) {
            throw new SQLStatementException("Missing starting clause");
        }

        StringBuilder str = new StringBuilder();
        if(type == INSERT_INTO) {
            str.append("INSERT INTO ");

            if(insertInto.first() == null) {
                throw new SQLStatementException("Invalid or missing INSERT_INTO clause");
            }
            str.append(insertInto.first()+" ");
            if(insertInto.second() != null && insertInto.second().length > 0) {
                str.append(arrayToString(insertInto.second(), "()", ","));
                str.append(" ");
            }

            if(values == null || values.length == 0) {
                throw new SQLStatementException("Invalid or missing VALUES clause");
            }
            str.append("VALUES ");
            str.append(arrayToString(values, "()", ","));

        } else if(type == SELECT) {
            str.append("SELECT ");

            if(select == null) {
                throw new SQLStatementException("Invalid or missing SELECT clause");
            }
            if(select.length == 0) {
                str.append("*");
            } else {
                str.append(arrayToString(select, null, ","));
            }
            str.append(" ");

            if(from == null) {
                throw new SQLStatementException("Invalid or missing FROM clause");
            }
            str.append("FROM ");
            str.append(from);
            str.append(" ");

            if(where != null) {
                str.append("WHERE ");
                str.append(where);
                str.append(" ");
            }

            if(limit != null) {
                str.append("LIMIT ");
                str.append(limit);
                str.append(" ");
            }

            if(orderBy != null && orderBy.length > 0) {
                for(int i = 0; i < orderBy.length; i++) {
                    str.append(orderBy[i].first());
                    str.append(" ");
                    str.append(orderBy[i].second() == ASCENDING ? "ASC" : "DESC");
                    if(i != orderBy.length-1) {
                        str.append(", ");
                    }
                }
            }

        } else if(type == UPDATE) {
            str.append("UPDATE ");
            if(update == null) {
                throw new SQLStatementException("Invalid or missing UPDATE clause");
            }
            str.append(update);
            str.append(" ");

            if(set == null || set.length == 0) {
                throw new SQLStatementException("Invalid or missing SET clause");
            }
            for(int i = 0; i < set.length; i++) {
                str.append(set[i].first());
                str.append(" = ");
                str.append(set[i].second());
                if(i != set.length-1) {
                    str.append(", ");
                }
            }
            str.append(" ");

            if(where != null) {
                str.append("WHERE ");
                str.append(where);
                str.append(" ");
            }
        } else if(type == DELETE) {
            str.append("DELETE ");

            if(from == null) {
                throw new SQLStatementException("Invalid or missing FROM clause");
            }
            str.append("FROM ");
            str.append(from);
            str.append(" ");

            if(where != null) {
                str.append("WHERE ");
                str.append(where);
                str.append(" ");
            }
        }
        return str.toString().trim()+";";
    }
}
