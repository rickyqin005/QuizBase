package utility;

import java.util.ArrayList;

/**
 * A helper class that builds SQL Statements. Currently, only {@code INSERT INTO},
 * {@code SELECT}, {@code UPDATE} and {@code DELETE FROM} starting clauses are supported.
 *
 * The SQL Statement string is generated by calling the object's {@code .toString()} method.
 *
 * @author Ricky Qin
 */
public class SQLStatementBuilder {

    private static String ASCENDING = "ASC";
    private static String DESCENDING = "DESC";

    private static int INSERT_INTO = 1;
    private static int SELECT = 2;
    private static int UPDATE = 3;
    private static int DELETE_FROM = 4;

    /**
     * Formats the string into a SQL string literal by surrounding the string in single quotes
     * and escaping special characters ({@code '} is changed to {@code ''}).
     *
     * @param str The string
     * @return The formatted String
     */
    public static String toStringLiteral(String str) {
        return "'" + str.replace("'", "''") + "'";
    }

    private int type = -1;

    private Pair<String, String[]> insertInto;
    private String[] values;
    private String[] select;
    private String from;
    private String where;
    private Integer limit;
    private Pair<String, String>[] orderBy;
    private String update;
    private ArrayList<Pair<String, String>> set;
    private String deleteFrom;

    public SQLStatementBuilder() {}

    /**
     * Gets the type of SQL Statement.
     *
     * @return The type
     */
    public int getType() {
        return type;
    }

    /**
     * Appends the {@code INSERT TO} clause to this statement
     *
     * @param table The table to insert the new row
     * @param cols Some number of Strings, indicating the columns to populate. If no columns are specified,
     * the entire row is populated.
     * @return This SQL statement
     */
    public SQLStatementBuilder insertInto(String table, String... cols) {
        if(type != -1) {
            throw new SQLStatementBuilderException("Starting clause already exists");
        }
        type = INSERT_INTO;
        insertInto = new Pair<>(table, cols);
        return this;
    }

    /**
     * Appends the {@code VALUES} clause to this statement
     *
     * @param cols Some number of Objects, indicating the values to populate into the columns as specified
     * in the {@code INSERT INTO} clause. Any non-integer objects are converted to a string object
     * using its {@code .toString()} method. Should be called immediately after {@code .insertInto()}.
     * @return This SQL statement
     */
    public SQLStatementBuilder values(Object... cols) {
        values = new String[cols.length];
        for(int i = 0; i < cols.length; i++) {
            if(cols[i] instanceof Integer) {
                values[i] = ((Integer)cols[i]).toString();
            } else {
                values[i] = toStringLiteral(cols[i].toString());
            }

        }
        return this;
    }

    /**
     * Appends the {@code SELECT} clause to this statement
     *
     * @param cols Some number of Strings, indicating the columns to retrieve. If no columns are specified,
     * all of them will be retrieved.
     * @return This SQL statement
     */
    public SQLStatementBuilder select(String... cols) {
        if(type != -1) {
            throw new SQLStatementBuilderException("Starting clause already exists");
        }
        type = SELECT;
        select = cols;
        return this;
    }

    /**
     * Appends the {@code FROM} clause to this statement
     *
     * @param table The name of the table to retrieve data from. Should be called immediately after
     * {@code .select()}.
     * @return This SQL statement
     */
    public SQLStatementBuilder from(String table) {
        from = table;
        return this;
    }

    /**
     * Appends the {@code WHERE} clause to this statement
     *
     * @param condition A string representing the condition used to filter results. Can be used for
     * {@code SELECT}, {@code UPDATE} and {@code DELETE} statements.
     * Any special characters  must be escaped before calling this method
     * @return This SQL statement
     */
    public SQLStatementBuilder where(String condition) {
        where = condition;
        return this;
    }

    /**
     * Appends the {@code LIMIT} clause to this statement
     *
     * @param amt The maximum number of rows that can be returned by a query.
     * @return This SQL statement
     */
    public SQLStatementBuilder limit(int amt) {
        limit = amt;
        return this;
    }

    /**
     * Appends the {@code ORDER BY} clause to this statement
     *
     * @param cols The columns
     * @return This SQL statement
     */
    public SQLStatementBuilder orderBy(Pair<String, String>... cols) {
        orderBy = cols;
        return this;
    }

    /**
     * Appends the {@code UPDATE} clause to this statement
     *
     * @param table The name of the table in which to perform the update.
     * @return This SQL statement
     */
    public SQLStatementBuilder update(String table) {
        if(type != -1) {
            throw new SQLStatementBuilderException("Starting clause already exists");
        }
        type = UPDATE;
        update = table;
        return this;
    }

    /**
     * Appends the {@code SET} clause to this statement
     *
     * @param cols Some number of Pair objects, with the first value indicating the column to modify
     * and the second value indicating the new value.
     * @return This SQL statement
     */
    public SQLStatementBuilder set(Pair<String, Object>... cols) {
        set = new ArrayList<Pair<String, String>>();
        for(int i = 0; i < cols.length; i++) {
            if(cols[i].second() instanceof Integer) {
                set.add(new Pair<>(cols[i].first(), ((Integer)cols[i].second()).toString()));
            } else {
                set.add(new Pair<>(cols[i].first(), toStringLiteral(cols[i].second().toString())));
            }
        }
        return this;
    }

    /**
     * Appends the {@code DELETE FROM} clause to this statement
     *
     * @param table The name of the table to delete data from.
     * @return This SQL statement
     */
    public SQLStatementBuilder deleteFrom(String table) {
        if(type != -1) {
            throw new SQLStatementBuilderException("Starting clause already exists");
        }
        type = DELETE_FROM;
        deleteFrom = table;
        return this;
    }


    /**
     * Appends the {@code INSERT TO} clause to the generated SQL String.
     *
     * @param str The StringBuilder to append to.
     */
    private void appendInsertInto(StringBuilder str) {
        if(insertInto.first() == null || insertInto.second() == null) {
            throw new SQLStatementBuilderException("Invalid or missing INSERT_INTO clause");
        }
        str.append("INSERT INTO ");
        str.append(insertInto.first());
        str.append(" ");
        if(insertInto.second().length > 0) {
            str.append(arrayToString(insertInto.second(), "()", ","));
            str.append(" ");
        }
    }

    /**
     * Appends the {@code VALUES} clause to the generated SQL String.
     *
     * @param str The StringBuilder to append to.
     */
    private void appendValues(StringBuilder str) {
        if(values == null || values.length == 0) {
            throw new SQLStatementBuilderException("Invalid or missing VALUES clause");
        }
        str.append("VALUES ");
        str.append(arrayToString(values, "()", ","));
        str.append(" ");
    }

    /**
     * Appends the {@code SELECT} clause to the generated SQL String.
     *
     * @param str The StringBuilder to append to.
     */
    private void appendSelect(StringBuilder str) {
        str.append("SELECT ");

        if(select == null) {
            throw new SQLStatementBuilderException("Invalid or missing SELECT clause");
        }
        if(select.length == 0) {
            str.append("*");
        } else {
            str.append(arrayToString(select, null, ","));
        }
        str.append(" ");
    }

    /**
     * Appends the {@code FROM} clause to the generated SQL String.
     *
     * @param str The StringBuilder to append to.
     */
    private void appendFrom(StringBuilder str) {
        if(from == null) {
            throw new SQLStatementBuilderException("Invalid or missing FROM clause");
        }
        str.append("FROM ");
        str.append(from);
        str.append(" ");
    }

    /**
     * Appends the {@code WHERE} clause to the generated SQL String, if it exists.
     *
     * @param str The StringBuilder to append to.
     */
    private void appendWhere(StringBuilder str) {
        if(where != null) {
            str.append("WHERE ");
            str.append(where);
            str.append(" ");
        }
    }

    /**
     * Appends the {@code LIMIT} clause to the generated SQL String, if it exists.
     *
     * @param str The StringBuilder to append to.
     */
    private void appendLimit(StringBuilder str) {
        if(limit != null) {
            str.append("LIMIT ");
            str.append(limit);
            str.append(" ");
        }
    }

    /**
     * Appends the {@code ORDER BY} clause to the generated SQL String, if it exists.
     *
     * @param str The StringBuilder to append to.
     */
    private void appendOrderBy(StringBuilder str) {
        if(orderBy != null && orderBy.length > 0) {
            str.append("ORDER BY ");
            for(int i = 0; i < orderBy.length; i++) {
                str.append(orderBy[i].first());
                str.append(" ");
                str.append(orderBy[i].second().equals(ASCENDING) ? "ASC" : "DESC");
                if(i != orderBy.length-1) {
                    str.append(", ");
                }
            }
            str.append(" ");
        }
    }

    /**
     * Appends the {@code UPDATE} clause to the generated SQL String.
     *
     * @param str The StringBuilder to append to.
     */
    private void appendUpdate(StringBuilder str) {
        str.append("UPDATE ");
        if(update == null) {
            throw new SQLStatementBuilderException("Invalid or missing UPDATE clause");
        }
        str.append(update);
        str.append(" ");
    }

    /**
     * Appends the {@code SET} clause to the generated SQL String.
     *
     * @param str The StringBuilder to append to.
     */
    private void appendSet(StringBuilder str) {
        if(set == null || set.size() == 0) {
            throw new SQLStatementBuilderException("Invalid or missing SET clause");
        }
        str.append("SET ");
        for(int i = 0; i < set.size(); i++) {
            str.append(set.get(i).first());
            str.append(" = ");
            str.append(set.get(i).second());
            if(i != set.size()-1) {
                str.append(", ");
            }
        }
        str.append(" ");
    }

    /**
     * Appends the {@code DELETE FROM} clause to the generated SQL String.
     *
     * @param str The StringBuilder to append to.
     */
    private void appendDeleteFrom(StringBuilder str) {
        if(deleteFrom == null) {
            throw new SQLStatementBuilderException("Invalid or missing DELETE FROM clause");
        }
        str.append("DELETE FROM ");
        str.append(deleteFrom);
        str.append(" ");
    }

    /**
     * Returns the String array as a list
     *
     * @param arr The string array
     * @param brackets The surrounding brackets, where the first and last characters are the
     * opening and closing brackets respectively. If {@code null}, no brackets are used.
     * @param delimiter The delimiter
     * @return A string
     */
    private static String arrayToString(String[] arr, String brackets, String delimiter) {
        StringBuilder str = new StringBuilder();
        if(brackets != null) {
            str.append(brackets.charAt(0));
        }
        for(int i = 0; i < arr.length; i++) {
            str.append(arr[i]);
            if(i != arr.length-1) {
                str.append(delimiter);
            }
        }
        if(brackets != null) {
            str.append(brackets.charAt(1));
        }
        return str.toString();
    }

    /**
     * Outputs this object as an SQL Statement
     *
     * @return The string
     */
    @Override
    public String toString() {
        StringBuilder str = new StringBuilder();
        if(type == INSERT_INTO) {
            appendInsertInto(str);
            appendValues(str);
        } else if(type == SELECT) {
            appendSelect(str);
            appendFrom(str);
            appendWhere(str);
            appendLimit(str);
            appendOrderBy(str);

        } else if(type == UPDATE) {
            appendUpdate(str);
            appendSet(str);
            appendWhere(str);

        } else if(type == DELETE_FROM) {
            appendDeleteFrom(str);
            appendWhere(str);
        } else {
            throw new SQLStatementBuilderException("Missing starting clause");
        }
        return str.toString().trim()+";";
    }
}
